<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="style" href="styles.css">
    <title>Tetris</title>
</head>
<style>
#game{
    width: 330px;
    height: 660px;
    border: solid black 1px;
    display: flex;
    flex-direction: column;
}
#preview {
    width: 100px;
    height: 100px;
    border: solid black 1px;
    display: flex;
    flex-direction: column;
}
#preview-cell {
    /* border: 1px solid gray; */
}
#preview-row {
    display: flex;
    flex-direction: row;
}
#game-cell {
    border: 1px solid gray;
}
#game-row {
    display: flex;
    flex-direction: row;
}
.blue {
    background-color: blue;
}
</style>

<body>
    <h2 style="text-align: center;">
        Tetris
    </h2>
    
    <div style="display: flex; justify-content: center; justify-content: center;">
        <div style="display: flex; flex-direction: column; align-items: center; margin: 5px;">
            <div id="preview">
                <div>
                    This should not show
                </div>
            </div>
            <div style="display: flex; flex-direction: column; justify-content: center; margin: 10px;">

                <button id="cycleButton">cycle</button>
                <button id="rotate">rotate</button>
            </div>
        </div>
        <div id="game">
            <div>
                This should not show
            </div>
        </div>
    </div>
</body>
<script defer>
    const counterClockwiseRotationMatrix = [
        [0, 1],
        [-1, 0]
    ]

    const clockwiseRotationMatrix = counterClockwiseRotationMatrix.map(row => row.map(val => val * -1))

    function transpose(A) {
        const rows = A.length;
        const cols = A[0].length;

        const result = Array.from({ length: cols }, () =>
            Array(rows).fill(0)
        );

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
            result[j][i] = A[i][j];
            }
        }

        return result;
    }

    function multiplyMatrices(A, B) {
        const aRows = A.length;
        const aCols = A[0].length;
        const bRows = B.length;
        const bCols = B[0].length;

        if (aCols !== bRows) {
            throw new Error("Matrix dimensions do not match for multiplication.");
        }

        // Create result matrix filled with zeros
        const result = Array.from({ length: aRows }, () =>
            Array(bCols).fill(0)
        );

        // Multiply
        for (let i = 0; i < aRows; i++) {
            for (let j = 0; j < bCols; j++) {
                for (let k = 0; k < aCols; k++) {
                    result[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return result;
    }

    function rotatePositionClockwise(pos) {
        return (multiplyMatrices(clockwiseRotationMatrix, pos))
    }

    function rotatePositionCounterClockwise(pos) {
        return (multiplyMatrices(counterClockwiseRotationMatrix, pos))
    }

    function deepCopy(obj){
        return JSON.parse(JSON.stringify(obj))
    }

    const pieceTypeMap = [
        {
            color: "blue",
            positions: [ // square
                [0, 0],
                [1, 0],
                [0, 1],
                [1, 1],
            ],
            rotation: false,
            previewPosition: [1,1]
        },
        {
            color: "blue",
            positions: [ //line
                [-1,0],
                [0, 0],
                [1, 0],
                [2, 0],
            ],
            previewPosition: [1,1]
        },
        {
            color: "blue", //trident
            positions: [
                [1, 0],
                [0, 0],
                [0, 1],
                [0,-1],
            ],
            previewPosition: [1,1]
        },
        {
            color: "blue", //zig
            positions: [
                [1, 0],
                [0, 0],
                [0, -1],
                [-1,-1],
            ],
            previewPosition: [1,1]
        },
        {
            color: "blue", //zag
            positions: [
                [1, 0],
                [0, 0],
                [0, 1],
                [-1, 1],
            ],
            previewPosition: [0,0]
        },
        {
            color: "blue", //left crook
            positions: [
                [0, -1],
                [0, 0],
                [1, 0],
                [2, 0],
            ],
            previewPosition: [1,1]
        },
        {
            color: "blue", //right crook
            positions: [
                [0, 1],
                [0, 0],
                [1, 0],
                [2, 0],
            ],
            previewPosition: [1,1]
        },
    ]

    class Board {
        /** !Array<Array<any>> */  
        _virtualBoard = [];
        _htmlBoard;
        _rowHeight;
        _rowWidth;
        /***
         * @param {number} rows
         * @param {number} cols
         * @param {string} boardId
         */
        constructor(rows, cols, boardId){
            this._rows = rows
            this._cols = cols
            this.boardId = boardId
            this._htmlBoard = document.getElementById(boardId)
            // console.log(this._htmlBoard);
            this._htmlBoard.replaceChildren([])
            
            this._rowHeight = 1 / rows * 100
            this._cellWidth = 1 / cols * 100
            for (let i = 0; i < rows; i++) {
                const vRow = new Array(cols).fill(null)
                this._virtualBoard.push(vRow)
                const htmlRow = this.createHtmlRow()

                for (let j = 0; j < cols; j++) {
                    const htmlCell = this.createHtmlCell()
                    htmlRow.appendChild(htmlCell)
                }
                this._htmlBoard.appendChild(htmlRow)
            }
        }

        createHtmlCell() {
            const cell = document.createElement("div")
            // console.log(this._cellWidth);
            
            cell.style.width = this._cellWidth + "%";
            cell.style.height = "100%"
            // cell.style.margin = "1px"
            cell.id = this.boardId + "-cell"
            return cell
        }

        createHtmlRow() {
            const row = document.createElement("div")
            row.style.width = "100%"
            row.style.height = this._rowHeight + "%"
            row.id = this.boardId + "-row"
            return row
        }

        
        /**
         * @param {number} row
         * @param {number} col
         * @param {CellState} cell
        */
        updateHtmlCellAt(row, col, cell){
            // const htmlCell = this._htmlBoard.children.item(i)?.children.item(j)
            const htmlCell = this._htmlBoard.children[row].children[col]
            if (htmlCell == null) return
            const color = cell?.color
            if (color) {
                htmlCell.classList.add(color)
            }
        }

        clearHtmlBoard(){
            for (let i = 0; i < this._rows; i++) {
                for (let j = 0; j < this._cols; j++) {
                    const htmlCell = this._htmlBoard.children[i].children[j]
                    htmlCell.classList.value = ""
                }
            }
        }

        render(){
            console.log("rendering");
            this.clearHtmlBoard()
            for (let i = 0; i < this._rows; i++) {
                for (let j = 0; j < this._cols; j++) {
                    this.updateHtmlCellAt(i, j, this._virtualBoard[i][j])
                }
            }
        }

        displayPieceOnBoardAt(piece, row, col) {
            piece.positions.forEach(([rOff,cOff]) => {
                this.setVBoardAt(row + rOff, col + cOff, {color: piece.color})
            })
        }

        setVBoardAt(row, col, val) {
            if(row < 0 || col < 0 || row > this._virtualBoard.length -1  || col > this._virtualBoard[0].length -1) return
            this._virtualBoard[row][col] = val
        }

        clearVirtualBoard(){
             for (let i = 0; i < this._rows; i++) {
                for (let j = 0; j < this._cols; j++) {
                   this._virtualBoard[i][j] = null
                }
            }
        }
        
    }

    /***
     * @param {!Board} board
     * @param {!Board} previewBoard
     * @param {Record<string, any>} state
    */
    function gameLoop(board, previewBoard, state) {
        //calculate next state
        // console.log(state);
        board.clearVirtualBoard()
        
        //draw all dead cells
        Object.entries(state.deadCellMap).forEach(([idx, cell]) => {
            const [row, col] = idx.split("-").map(v => Number(v))
            board.setVBoardAt(row, col, cell)
        })
        
        if(state.tick == 0){
            console.log("move down");
            
        }
        //move the moving piece down
        const nextPositions = state.movingPiece.positions.map((pos) => [pos[0] + 1 + state.movingPiecePosition[0], pos[1] + state.movingPiecePosition[0]])
        console.log("nextPositions:", nextPositions);
        

        if(state.rotate) {
            state.movingPiece.positions = 
                state.movingPiece.positions.map((pos) => 
                    transpose(
                        rotatePositionCounterClockwise(
                            transpose([pos])))[0]
                )
            state.rotate = false
        }

        //calc next board
        console.log(state.movingPiece, state.movingPiecePosition[0], state.movingPiecePosition[1]);
        
        board.displayPieceOnBoardAt(state.movingPiece, state.movingPiecePosition[0]++, state.movingPiecePosition[1]);

        console.log(previewBoard);
        
        previewBoard.clearVirtualBoard()
        const nextPiece = pieceTypeMap[state.nextPieceIdx]
        previewBoard.displayPieceOnBoardAt(nextPiece, 1, 1 )
        // console.log(board._virtualBoard);
        

        //render the board
        previewBoard.render()
        board.render()
        state.tick = (state.tick + 1) % state.gameSpeed;
    }
    
    function getRandomPieceIdx(){
        return Math.floor((Math.random() * 10) % 7)
    }

    function main() {
        
        
        let gameSpeed = 500

        const gameBoardId = "game"
        const gameBoard = new Board(20, 10, gameBoardId)

        const previewBoardId = "preview"
        const previewBoard = new Board(4, 4, previewBoardId)

        const firstPieceIdx = getRandomPieceIdx()

        const state = {
            movingPiece: deepCopy(pieceTypeMap[firstPieceIdx]),
            movingPiecePosition: [-2, Math.floor(gameBoard._cols / 2)],
            nextPieceIdx: getRandomPieceIdx(),
            pieceIdx: firstPieceIdx,
            rotate: false,
            deadCellMap: {},
            tick: 0,
        }

        document.getElementById("cycleButton").addEventListener("click", () => {
            state.pieceIdx = (state.pieceIdx + 1) % 7
            state.nextPieceIdx = (state.pieceIdx + 1) % 7
            state.movingPiece = deepCopy(pieceTypeMap[state.pieceIdx])
        })

        document.getElementById("rotate").addEventListener("click", () => {
            state.rotate = true
        })

        console.log("initial state: ", state);
        
        gameLoop(gameBoard, previewBoard, state)

        setInterval(() => {
            gameLoop(gameBoard, previewBoard, state)
            // console.log("tick - ", gameSpeed);
            // console.log(state);
        }, gameSpeed)


    }
    main()

</script>
</html>